//
//  Random.swift
//  NumericAnnex
//
//  Created by Xiaodi Wu on 5/13/17.
//

#if os(Linux)
import Glibc
#else
import Darwin
#endif

/// A pseudo-random number generator.
///
/// The generator implements [`xorshift128+`][ref], an efficient linear-feedback
/// shift register that uses 128 bits of internal state.
///
/// [ref]: http://vigna.di.unimi.it/ftp/papers/xorshiftplus.pdf
/* public */ final class Random : IteratorProtocol, Sequence {
  /// The maximum value that may be generated by the pseudo-random number
  /// generator.
  public static let max = UInt64.max

  /// The minimum value that may be generated by the pseudo-random number
  /// generator.
  public static let min = UInt64.min

  /// The internal state of the pseudo-random number generator.
  public var state: (UInt64, UInt64)

  /// Creates a pseudo-random number generator with the given internal state.
  ///
  /// - Parameters:
  ///   - state: The value to be used as the generator's internal state.
  public init(state: (UInt64, UInt64)) {
    self.state = state
  }

  /// Creates a pseudo-random number generator with a random internal state by
  /// reading data from `/dev/urandom`.
  ///
  /// If no data can be read from `/dev/urandom`, the result is `nil`.
  public convenience init?() {
    // Why read data from `/dev/urandom`? See:
    // https://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/
    guard let file = fopen("/dev/urandom", "rb") else { return nil }
    defer { fclose(file) }
    let size = MemoryLayout<UInt64>.size
    var read = 0
    var state = (0 as UInt64, 0 as UInt64)
    withUnsafeMutablePointer(to: &state) { ptr in
      read = fread(ptr, size, 2, file)
    }
    guard read == 2 else { return nil }
    self.init(state: state)
  }

  /// Advances to the next internal state and returns a value in the closed
  /// range `Random.min...Random.max`.
  public func next() -> UInt64? {
    // An implementation of `xorshift128+`.
    var x = state.0
    let y = state.1
    state.0 = y
    x ^= x &<< 23
    state.1 = x ^ y ^ (x &>> 17) ^ (y &>> 26)
    return state.1 &+ y
  }
}

// TODO: Document methods in this extension.
extension Random {
  // @_versioned
  internal func _canonical<T : BinaryFloatingPoint>(
    _: T.Type = T.self, bits: Int = T.significandBitCount
  ) -> T {
    let bits = Swift.min(bits, T.significandBitCount)
    // `Element` must be unsigned or the following computation may overflow.
    let difference = Random.max - Random.min
    let (quotient, remainder) = bits.quotientAndRemainder(
      dividingBy: difference == Element.max
        ? Element.bitWidth
        : Element.bitWidth - (difference + 1).leadingZeroBitCount - 1
    )
    let k = Swift.max(1, remainder == 0 ? quotient : quotient + 1)
    let step = T(difference)
    let initial = (0 as T, 1 as T)
    // Call `next()` exactly `k` times.
    let (dividend, divisor) = prefix(k).reduce(initial) { partial, next in
      let x = partial.0 + T(next - Random.min) * partial.1
      let y = partial.1 + step * partial.1
      return (x, y)
    }
    return dividend / divisor
  }

  @_transparent // @_inlineable
  public func uniform<T : BinaryFloatingPoint>(_: T.Type = T.self) -> T {
    return uniform(a: 0, b: 1)
  }

  @_transparent // @_inlineable
  public func uniform<T : BinaryFloatingPoint>(
    _: T.Type = T.self, count: Int
  ) -> UnfoldSequence<T, Int> {
    return uniform(a: 0, b: 1, count: count)
  }

  public func uniform<T : BinaryFloatingPoint>(
    _: T.Type = T.self, a: T, b: T
  ) -> T {
    precondition(b > a, "Uniform distribution parameter b should be greater than a")
    return (b - a) * _canonical() + a
  }

  @_transparent // @_inlineable
  public func uniform<T : BinaryFloatingPoint>(
    _: T.Type = T.self, a: T, b: T, count: Int
  ) -> UnfoldSequence<T, Int> {
    precondition(count >= 0, "Element count should be non-negative")
    return sequence(state: 0) { (state: inout Int) -> T? in
      defer { state += 1 }
      return state == count ? nil : self.uniform(a: a, b: b)
    }
  }
}
